<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - FBX loader</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>

  <body>
    <div id="info">
      <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
      - FBXLoader<br />
      Character and animation from
      <a href="https://www.mixamo.com/" target="_blank" rel="noopener"
        >Mixamo</a
      >
    </div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      import Stats from "three/addons/libs/stats.module.js";

      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";

      let camera, scene, renderer, stats;

      const clock = new THREE.Clock();

      let mixer;

      const crossFadeControls = [];

      let currentBaseAction = "idle";
      const allActions = [];
      const baseActions = {
        Idle_A: { weight: 1 },
        Jump: { weight: 0 },
        Eat: { weight: 0 },
        Roll: { weight: 0 },
      };
      let panelSettings, numAnimations;

      init();
      animate();

      function init() {
        const container = document.createElement("div");
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          1,
          2000
        );
        camera.position.set(100, 200, 300);
        // camera.position.set( 500, 800, 1300 );
        // camera.lookAt( 0, 0, 0 );

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x46a094);
        // scene.fog = new THREE.Fog( 0xa0a0a0, 200, 1000 );

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        hemiLight.position.set(0, 200, 0);
        scene.add(hemiLight);

        // const gridHelper = new THREE.GridHelper( 1000, 20 );
        // scene.add( gridHelper );
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(0, 200, 100);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 180;
        dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.camera.left = -120;
        dirLight.shadow.camera.right = 120;
        scene.add(dirLight);

        // scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );

        // ground
        const mesh = new THREE.Mesh(
          new THREE.PlaneGeometry(2000, 2000),
          new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false })
        );
        mesh.rotation.x = -Math.PI / 2;
        mesh.receiveShadow = true;
        scene.add(mesh);

        const grid = new THREE.GridHelper(2000, 20, 0x000000, 0x000000);
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add(grid);

        // model
        const loader = new FBXLoader();
        loader.load("Sparrow_Animations.fbx", function (object) {
          const animations = object.animations;
          console.log(object);
          mixer = new THREE.AnimationMixer(object);
          numAnimations = animations.length;
          console.log(animations);

          for (let i = 0; i !== numAnimations; ++i) {
            let clip = animations[i];
            const name = clip.name;

            if (baseActions[name]) {
              const action = mixer.clipAction(clip);
              activateAction(action);
              baseActions[name].action = action;
              allActions.push(action);
            }
          }

          const action = mixer.clipAction(object.animations[9]);
          action.play();

          object.traverse(function (child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });

          scene.add(object);
          createPanel();
        });

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 100, 0);
        controls.update();

        window.addEventListener("resize", onWindowResize);

        // stats
        stats = new Stats();
        container.appendChild(stats.dom);
      }

      function activateAction(action) {
        const clip = action.getClip();
        const settings = baseActions[clip.name] || additiveActions[clip.name];
        setWeight(action, settings.weight);
        action.play();
      }

      function setWeight(action, weight) {
        action.enabled = true;
        action.setEffectiveTimeScale(1);
        action.setEffectiveWeight(weight);
      }

      function synchronizeCrossFade(startAction, endAction, duration) {
        mixer.addEventListener("loop", onLoopFinished);

        function onLoopFinished(event) {
          if (event.action === startAction) {
            mixer.removeEventListener("loop", onLoopFinished);
            // console.log("fade!!!!!")
            // console.log(startAction)
            // console.log(endAction)

            executeCrossFade(startAction, endAction, duration);
          }
        }
      }

      function executeCrossFade(startAction, endAction, duration) {
        console.log("Start");
        console.log(startAction);

        // Not only the start action, but also the end action must get a weight of 1 before fading
        // (concerning the start action this is already guaranteed in this place)

        if (endAction) {
          setWeight(endAction, 1);
          endAction.time = 0;

          if (startAction) {
            // Crossfade with warping

            startAction.crossFadeTo(endAction, duration, true);
          } else {
            // Fade in

            endAction.fadeIn(duration);
          }
        } else {
          // Fade out

          startAction.fadeOut(duration);
        }
      }

      function createPanel() {
        const panel = new GUI({ width: 310 });

        const folder1 = panel.addFolder("Base Actions");
        const folder2 = panel.addFolder("Additive Action Weights");
        const folder3 = panel.addFolder("General Speed");

        panelSettings = {
          "modify time scale": 1.0,
        };

        const baseNames = ["None", ...Object.keys(baseActions)];
        console.log(baseNames);

        for (let i = 0, l = baseNames.length; i !== l; ++i) {
          const name = baseNames[i];
          const settings = baseActions[name];
          console.log(name);
          panelSettings[name] = function () {
            const currentSettings = baseActions[currentBaseAction];
            const currentAction = currentSettings
              ? currentSettings.action
              : null;
            const action = settings ? settings.action : null;
            if (currentAction !== action) {
              prepareCrossFade(currentAction, action, 0.35);
            }
          };

          crossFadeControls.push(folder1.add(panelSettings, name));
        }

        // for ( const name of Object.keys( additiveActions ) ) {

        // 	const settings = additiveActions[ name ];

        // 	panelSettings[ name ] = settings.weight;
        // 	folder2.add( panelSettings, name, 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {

        // 		setWeight( settings.action, weight );
        // 		settings.weight = weight;

        // 	} );

        // }

        // folder3.add( panelSettings, 'modify time scale', 0.0, 1.5, 0.01 ).onChange( modifyTimeScale );

        folder1.open();
        folder2.open();
        folder3.open();

        crossFadeControls.forEach(function (control) {
          control.setInactive = function () {
            control.domElement.classList.add("control-inactive");
          };

          control.setActive = function () {
            control.domElement.classList.remove("control-inactive");
          };

          const settings = baseActions[control.property];

          if (!settings || !settings.weight) {
            control.setInactive();
          }
        });
      }

      function prepareCrossFade(startAction, endAction, duration) {
        // If the current action is 'Idle_A', execute the crossfade immediately;
        // else wait until the current action has finished its current loop

        if (currentBaseAction === "Idle_A" || !startAction || !endAction) {
          executeCrossFade(startAction, endAction, duration);
        } else {
          synchronizeCrossFade(startAction, endAction, duration);
        }

        // Update control colors

        if (endAction) {
          const clip = endAction.getClip();
          currentBaseAction = clip.name;
        } else {
          currentBaseAction = "None";
        }

        crossFadeControls.forEach(function (control) {
          const name = control.property;

          if (name === currentBaseAction) {
            control.setActive();
          } else {
            control.setInactive();
          }
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      //

      function animate() {
        requestAnimationFrame(animate);

        // for ( let i = 0; i !== numAnimations; ++ i ) {

        // 	const action = allActions[ i ];
        // 	const clip = action.getClip();
        // 	const settings = baseActions[ clip.name ] || additiveActions[ clip.name ];
        // 	settings.weight = action.getEffectiveWeight();

        // }

        const mixerUpdateDelta = clock.getDelta();

        mixer.update(mixerUpdateDelta);
        stats.update();

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
